#[warn(unused_imports)]
use serde_json::value::Value;
use std::collections::HashMap;
use futures::executor::block_on;
use crate::conf::url::{
    Url, 
    load_url,
};
use crate::conf::conf::{
    load_conf,
};
// pop结构体
use crate::pop::six::Six as Sixp;
use crate::pop::sase::Sase;
use crate::pop::pop::Pop;
// cpe结构体
use crate::cpe::six::Six as Sixc;
use crate::cpe::cpe::Cpe;


pub fn init() -> Url {
    let path = String::from("/data/rust/xc/xc.toml");
    let conf = load_conf(path);
    let urlpath = conf.url.path;
    let url = load_url(urlpath);
    return url;
}

pub fn get_unixtime() -> i64 {
    let times = time::get_time();
    let t = times.sec * 1000 + (times.nsec as f64 / 1000.0 / 1000.0) as i64;
    return t;
}

async fn do_get_resp() -> Result<HashMap<std::string::String, Value>, reqwest::Error> {
    let client = reqwest::blocking::Client::new();
    let url = format!(
        "{}/matrix/oauth/token?client_id={}&client_secret={}&grant_type={}&password={}&username={}",
        CLENT_HOST = String::from("http://internal.oss.7x-networks.net"),
        CLIENT_ID = String::from("browser"),
        CLIENT_SECRET = String::from("b7n3i7kzg22y3p035rw3rd9sfzvs4cv0"),
        GRANT_TYPE = String::from("password"),
        PASSWORD = String::from("c8d064e2ad4670f418ba02ef342b33d1"),
        USERNAME = String::from("matrix")
    );

    Ok(client
        .post(url.as_str())
        .send()
        .unwrap()
        .json::<HashMap<String, Value>>()?)
}

async fn get_token_by_resp() -> String {
    let mut s = String::new();
    let result = do_get_resp().await;
    match result {
        Ok(v) => {
            let token = v.get("access_token");
            for tk in token.unwrap().to_string().split('"') {
                if tk.len() != 0 {
                    s = tk.to_string().clone()
                };
            } // Some(b) => let tk = b.unwrap().to_string()
        }
        Err(e) => println!("Error is {}", e),
    };
    return s;
    
}

pub async fn get_pops(base: String) -> String {
    let url = format!(
        "{}?&access_token={}&_={}",
        BASE = base,
        ACCESS_TOKEN = get_token_by_resp().await,
        CLENT_TIME   = get_unixtime(),
    );
    let res = reqwest::blocking::get(url.as_str()).unwrap();
    let body = res.text().unwrap();
    return body
}

pub async fn get_cpes(base: String) -> String {
    let url = format!(
        "{}?&access_token={}&_={}",
        BASE = base,
        ACCESS_TOKEN = get_token_by_resp().await,
        CLENT_TIME   = get_unixtime(),
    );
    let res = reqwest::blocking::get(url.as_str()).unwrap();
    let body = res.text().unwrap();
    return body
}

pub fn get_cpe(mode: String, sn: String) -> Option<Sixc> {
    match mode.clone().as_str() {
        "nexus" => {
            if let Some(base) = get_cpe_url_by_mode(mode) {
                let text = block_on(get_cpes(base)); 
                let v: Vec<Sixc> = serde_json::from_str(text.as_str()).unwrap();
                for sixc in v.iter() {
                    if sixc.sn == sn {
                        return Some(sixc.clone());
                    }
                }
            }
            return None;
        },
        "watsons" => {
            if let Some(base) = get_cpe_url_by_mode(mode) {
                let text = block_on(get_cpes(base)); 
                let v: Vec<Sixc> = serde_json::from_str(text.as_str()).unwrap();
                for sixc in v.iter() {
                    if sixc.sn == sn {
                        return Some(sixc.clone())
                    }
                }
            }
            return None;
        },
        "watsons_ha" => {
            if let Some(base) = get_cpe_url_by_mode(mode) {
                let text = block_on(get_cpes(base)); 
                let v: Vec<Sixc> = serde_json::from_str(text.as_str()).unwrap();
                for sixc in v.iter() {
                    if sixc.sn == sn {
                        return Some(sixc.clone())
                    }
                }
            }
            return None;
        },
        "valor" => {
            // if let Some(base) = get_cpe_url_by_mode(mode) {
            //     let text = get_cpes(base).await; 
            //     let v: Vec<Cpe> = serde_json::from_str(text.as_str()).unwrap();
            //     for cpe in v.iter() {
            //         if cpe.sn == sn {
            //             return Some(cpe.clone())
            //         }
            //     }
            //     return None
            // }
            // return None;
        },
        "tassadar" => {
            // if let Some(base) = get_cpe_url_by_mode(mode) {
            //     let text = get_cpes(base).await; 
            //     let v: Vec<Cpe> = serde_json::from_str(text.as_str()).unwrap();
            //     for cpe in v.iter() {
            //         if cpe.sn == sn {
            //             return Some(cpe.clone())
            //         }
            //     }
            //     return None
            // }
            // return None;
        },
        
        &_ => {
            return None;
        }
    };
    
    None
}

pub fn get_pop(mode: String, id: i64) -> Option<Sixp> {
    // let mode = String::from("valor");
    match mode.clone().as_str() {
        "nexus" => {
            if let Some(base) = get_pop_url_by_mode(mode) {
                let text = block_on(get_pops(base)); 
                let v: Vec<Sixp> = serde_json::from_str(text.as_str()).unwrap();
                for sixp in v.iter() {
                    if sixp.id == id {
                        return Some(sixp.clone())
                    }
                }
            }
            return None
        },
        "watsons" => {
            if let Some(base) = get_pop_url_by_mode(mode) {
                let text = block_on(get_pops(base));
                let v: Vec<Sixp> = serde_json::from_str(text.as_str()).unwrap();
                for sixp in v.iter() {
                    if sixp.id == id {
                        return Some(sixp.clone())
                    }
                }
            }
            return None
        },
        "watsons_ha" => {
            if let Some(base) = get_pop_url_by_mode(mode) {
                let text = block_on(get_pops(base));  
                let v: Vec<Sixp> = serde_json::from_str(text.as_str()).unwrap();
                for sixp in v.iter() {
                    if sixp.id == id {
                        return Some(sixp.clone())
                    }
                }
            }
            return None
        },
        "valor" => {
            // if let Some(base) = get_pop_url_by_mode(mode) {
            //     let text = block_on(get_pops(base)); 
            //     let v: Vec<Pop> = serde_json::from_str(text.as_str()).unwrap();
            //     for pop in v.iter() {
            //         if pop.id == id {
            //             return Some(pop.clone())
            //         }
            //     }
            // }
            // return None
        },
        "tassadar" => {
            // if let Some(base) = get_pop_url_by_mode(mode) {
            //     let text = block_on(get_pops(base)); 
            //     let v: Vec<Sase> = serde_json::from_str(text.as_str()).unwrap();
            //     for sasep in v.iter() {
            //         if sasep.id == id {
            //             return Some(sasep.clone())
            //         }
            //     }
            // }
            // return None
        },
        &_ => {
            return None;
        }
    }

    None
}

fn get_cpe_url_by_mode(mode: String) -> Option<String> {
    let u = init();
    if let Some(cpe) = u.get_cpe_string(mode) {
        return Some(cpe)
    }
    None
}

fn get_pop_url_by_mode(mode: String) -> Option<String> {
    let u = init();
    if let Some(pop) = u.get_pop_string(mode) {
        return Some(pop)
    }
    None
}
